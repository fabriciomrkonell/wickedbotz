#include <QTRSensors.h>
#include <Servo.h>

#define NUM_SENSORS             6
#define NUM_SAMPLES_PER_SENSOR  4
#define EMITTER_PIN             9
#define QTR_EMITTERS_ON         1

int potenciaE = 3;
int potenciaD = 6;
int motorE1 = 2;
int motorE2 = 4;
int motorD1 = 5;
int motorD2 = 7;
int angleServo = 90;

QTRSensorsAnalog qtra((unsigned char[]) {
  0, 1, 2, 3, 4, 5
}, NUM_SENSORS, NUM_SAMPLES_PER_SENSOR, EMITTER_PIN);
unsigned int sensorValues[NUM_SENSORS];

Servo servoMotor;

float Kp = 3, Ki = 0.2, Kd = 1;
float error = 0, P = 0, I = 0, D = 0, PID_value = 0;
float previous_error = 0, previous_I = 0;

float sensorWeightOne = 2;
float sensorWeightTwo = 0.5;
float sensorWeightThree = 0.1;
float err = 0;
int tolerance = 100;

int rP[8];

const int line = 500;

void setup() {
  Serial.begin(9600);
  pinMode(motorE1, OUTPUT);
  pinMode(motorE2, OUTPUT);
  pinMode(motorD1, OUTPUT);
  pinMode(motorD2, OUTPUT);
  pinMode(potenciaE, OUTPUT);
  pinMode(potenciaD, OUTPUT);
  digitalWrite(motorD1, HIGH);
  digitalWrite(motorD2, LOW);
  digitalWrite(motorE1, LOW);
  digitalWrite(motorE2, HIGH);

  pinMode(10, INPUT); // Central esquerdo
  pinMode(11, INPUT); // Central direito
  
  servoMotor.attach(8);
  servoMotor.write(90);
  qtra.emittersOn();
  delay(1000);


}


void loop() {
  qtra.calibrate();
  qtra.read(sensorValues, QTR_EMITTERS_OFF);
  //Serial.println(position);
  //calculatePID(position);
  //qtra.read(sensorValues);
  printValues(sensorValues);

};


void printValues(unsigned int s[NUM_SENSORS]) {

  rP[0] = s[2] / tolerance;
  rP[1] = s[0] / tolerance;
  rP[2] = s[1] / tolerance;
  rP[3] = digitalRead(10);
 
  rP[4] = digitalRead(11);
  rP[5] = s[4] / tolerance;
  rP[6] = s[5] / tolerance;
  rP[7] = s[3] / tolerance;

  //printValues2(rP);

  if (rP[0] == 0) err = 13.5;
  else if (rP[7] == 0) err = -13.5;
  else if (rP[1] == 0) err = 4.5;
  else if (rP[6] == 0) err = -4.5;
  else if (rP[2] == 0) err = 1.5;
  else if (rP[5] == 0) err = -1.5;
  else if (rP[3] == 0 && rP[4] == 0) err = 0;
  else if (rP[4] == 0) err = 0.5;
  else if (rP[3] == 0) err = -0.5;

  calculatePID(err);

};

void printValues2(int s[8]) {

  Serial.print("->");
  Serial.print(s[7]);
  Serial.print(" - ");
  Serial.print(s[6]);
  Serial.print(" - ");
  Serial.print(s[5]);
  Serial.print(" - ");
  Serial.print(s[4]);
  Serial.print(" - ");
  Serial.print(s[3]);
  Serial.print(" - ");
  Serial.print(s[2]);
  Serial.print(" - ");
  Serial.print(s[1]);
  Serial.print(" - ");
  Serial.println(s[0]);
};

void calculatePID(float error) {
  
  P = error;
  I = I + previous_I;
  D = error - previous_error;
  PID_value = (Kp * P) + (Ki * I) + (Kd * D);
  previous_I = I;
  previous_error = error;
    
  angleServo += PID_value;  
  if (angleServo < 10) {
    angleServo = 10;
    analogWrite(potenciaD, 150);
    analogWrite(potenciaE, 0);
  } else if (angleServo > 170) {
    angleServo = 170;
    analogWrite(potenciaD, 0);
    analogWrite(potenciaE, 150);
  } else {
    analogWrite(potenciaD, 55);
    analogWrite(potenciaE, 55);
  }
  
  Serial.print("\t\t");
  Serial.println(PID_value);
  
};
