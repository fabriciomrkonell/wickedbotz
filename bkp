#include <QTRSensors.h>
#include <Wire.h>

QTRSensorsAnalog qtr((unsigned char[]) {0, 1, 2, 3, 4}, 5, 4, QTR_NO_EMITTER_PIN);
unsigned int sensors[5];

int potenciaE = 3;
int potenciaD = 6;
int motorE1 = 2;
int motorE2 = 4;
int motorD1 = 5;
int motorD2 = 7;

int last_proportional;
int integral;

void setup(){
  Serial.begin(9600);
  pinMode(motorE1, OUTPUT);
  pinMode(motorE2, OUTPUT);
  pinMode(motorD1, OUTPUT);
  pinMode(motorD2, OUTPUT);
  pinMode(potenciaE, OUTPUT);
  pinMode(potenciaD, OUTPUT);
  digitalWrite(motorD1, HIGH);
  digitalWrite(motorD2, LOW);
  digitalWrite(motorE1, LOW);
  digitalWrite(motorE2, HIGH);
  set_motors(0, 0);
  delay(500);
  unsigned int counter; // usado como um simples contador
  for(counter=0; counter < 80; counter++){
    if(counter < 20 || counter >= 60){
      set_motors(50,-50); // Gira para a direita
    }
    else{
      set_motors(-50,50); // Gira para a esquerda
    }
    // Esta função armazena um conjunto de leituras dos sensores, e mantém
    // informações sobre o máximo e mínimo valores encontrados
    qtr.calibrate();
    // Desde que contamos até 80, o total do tempo de calibração
    // será de 80 * 10 = 800 ms
    delay(5);
  }
  set_motors(0,0); // Garante motores parados após o processo
                   // de calibração
  delay(1000);
  // Enquanto botão não é pressionado
  // mostra a posição da linha em relação aos sensores no console serial
  // usado para debug
  /*
  while(!button.isPressed()){
    unsigned int position = qtr.readLine(sensors);
    Serial.println(position);
  }
  */
}


// Esta é a função principal, onde o código inicia. Todo programa Arduino
// deve ter uma função loop() definida em algum lugar
void loop(){



    // Aqui não estamos interessados nos valores individuais de cada sensor
    unsigned int position = qtr.readLine(sensors);

    Serial.println(position);

    // O termo proporcional deve ser 0 quando estamos na linha
    int proportional = ((int)position) - 2000;

    // Calcula o termo derivativo (mudança) e o termo integral (soma)
    // da posição
    int derivative = proportional - last_proportional;
    integral += proportional;

    // Lembrando a ultima posição
    last_proportional = proportional;

    // Calcula a diferença entre o aranjo de potência dos dois motores
    // m1 - m2. Se for um número positivo, o robot irá virar para a
    // direita. Se for um número negativo, o robot irá virar para a esquerda
    // e a magnetude dos números determinam a agudez com que fará as curvas/giros
    int power_difference = proportional/1 + integral/10000 + derivative*2;//3/2;

    // Calcula a configuração atual dos motores.  Nunca vamos configurar
    // um motor com valor negativo
    const int max = 70;
    if(power_difference > max)
      power_difference = max;
    if(power_difference < -max)
      power_difference = -max;
    if(power_difference < 0)
      set_motors(max+power_difference, max);
    else
      set_motors(max, max-power_difference);

}


void set_motors(int left_speed, int right_speed){

  //Serial.println(left_speed);
  //Serial.println(right_speed);

  //Frente
  if(right_speed >= 0 && left_speed >= 0){
    digitalWrite(motorD1, HIGH);
    digitalWrite(motorD2, LOW);
    digitalWrite(motorE1, LOW);
    digitalWrite(motorE2, HIGH);
    analogWrite(potenciaD, right_speed);
    analogWrite(potenciaE, left_speed);
  }

  // Gira para a direita
  if(right_speed >= 0 && left_speed < 0){
    left_speed = -left_speed;
    digitalWrite(motorD1, HIGH);
    digitalWrite(motorD2, LOW);
    digitalWrite(motorE1, HIGH);
    digitalWrite(motorE2, LOW);
    analogWrite(potenciaD, right_speed);
    analogWrite(potenciaE, left_speed);
  }

  // Gira para a esquerda
  if(right_speed < 0 && left_speed >= 0){
    right_speed = -right_speed;
    digitalWrite(motorD1, LOW);
    digitalWrite(motorD2, HIGH);
    digitalWrite(motorE1, LOW);
    digitalWrite(motorE2, HIGH);
    analogWrite(potenciaD, right_speed);
    analogWrite(potenciaE, left_speed);

  }
}
